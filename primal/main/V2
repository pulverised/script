local Primal = loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/main/dist/main.lua"))()

--// Localization
Primal:Localization({
    Enabled = true,
    Prefix = "loc:",
    DefaultLanguage = "en",
    Translations = {
        ["en"] = {
            ["PRIMAL_EXAMPLE"] = "Primal Example",
            ["WELCOME"] = "Welcome to Primal!",
            ["LIB_DESC"] = "Beautiful UI library for Roblox",
            ["SETTINGS"] = "Settings",
            ["APPEARANCE"] = "Appearance",
            ["FEATURES"] = "Features",
            ["UTILITIES"] = "Utilities",
            ["UI_ELEMENTS"] = "UI Elements",
            ["CONFIGURATION"] = "Configuration",
            ["SAVE_CONFIG"] = "Save Configuration",
            ["LOAD_CONFIG"] = "Load Configuration",
            ["THEME_SELECT"] = "Select Theme",
            ["TRANSPARENCY"] = "Window Transparency"
        }
    }
})

Primal.TransparencyValue = 0.2
Primal:SetTheme("Dark")

--// Gradient helper
local function gradient(text, startColor, endColor)
    local result = ""
    for i = 1, #text do
        local t = (i - 1) / (#text - 1)
        local r = math.floor((startColor.R + (endColor.R - startColor.R) * t) * 255)
        local g = math.floor((startColor.G + (endColor.G - startColor.G) * t) * 255)
        local b = math.floor((startColor.B + (endColor.B - startColor.B) * t) * 255)
        result = result .. string.format('<font color="rgb(%d,%d,%d)">%s</font>', r, g, b, text:sub(i, i))
    end
    return result
end

--// Popup demo
Primal:Popup({
    Title = gradient("Primal Demo", Color3.fromHex("#6A11CB"), Color3.fromHex("#2575FC")),
    Icon = "sparkles",
    Content = "loc:LIB_DESC",
    Buttons = {
        {
            Title = "Get Started",
            Icon = "arrow-right",
            Variant = "Primary",
            Callback = function() end
        }
    }
})

local player = game.Players.LocalPlayer

local Window = Primal:CreateWindow({
    Title = "loc:Primal",
    Icon = "geist:window",
    Author = "loc:WELCOME",
    Folder = "Primal_main",
    Size = UDim2.fromOffset(580, 490),
    Theme = "Dark",
    User = {
        Enabled = true,
        Anonymous = false,          -- set to false to show actual user
        Name = player.Name,         -- local player name
        AvatarId = player.UserId,   -- local player Roblox ID for profile picture
        Callback = function()
            Primal:Notify({
                Title = "User Profile",
                Content = "Hello, "..player.Name.."!",
                Duration = 3
            })
        end
    },
    Acrylic = true,
    HideSearchBar = false,
    SideBarWidth = 200,
})

Window:Tag({ Title = "v1", Color = Color3.fromHex("#30ff6a") })
Window:Tag({ Title = "Beta", Color = Color3.fromHex("#315dff") })

local TimeTag = Window:Tag({
    Title = "--:--",
    Radius = 0,
    Color = Primal:Gradient({
        ["0"]   = { Color = Color3.fromHex("#FF0F7B"), Transparency = 0 },
        ["100"] = { Color = Color3.fromHex("#F89B29"), Transparency = 0 },
    }, { Rotation = 45 }),
})

--// Clock update
task.spawn(function()
    local hue = 0
    while true do
        local now = os.date("*t")
        local hours = string.format("%02d", now.hour)
        local minutes = string.format("%02d", now.min)
        hue = (hue + 0.01) % 1
        TimeTag:SetTitle(hours .. ":" .. minutes)
        task.wait(0.06)
    end
end)

--// Theme switcher button
Window:CreateTopbarButton("theme-switcher", "moon", function()
    Primal:SetTheme(Primal:GetCurrentTheme() == "Dark" and "Light" or "Dark")
    Primal:Notify({
        Title = "Theme Changed",
        Content = "Current theme: "..Primal:GetCurrentTheme(),
        Duration = 2
    })
end, 990)

--// Tabs
local Tabs = {
    Main = Window:Section({ Title = "Main", Opened = true }),
    Visuals = Window:Section({ Title = "Visuals" }),
    Rage = Window:Section({ Title = "Rage" }),
    Misc = Window:Section({ Title = "Misc" }),
    Credits = Window:Section({ Title = "Credits" }),
    Settings = Window:Section({ Title = "Settings" }),
}

--// Tab Handles
local TabHandles = {
    MainTab = Tabs.Main:Tab({ Title = "Main Features", Icon = "swords" }),
    VisualsTab = Tabs.Visuals:Tab({ Title = "Visuals", Icon = "eye" }),
    RageTab = Tabs.Rage:Tab({ Title = "Rage Features", Icon = "flame" }),
    MiscTab = Tabs.Misc:Tab({ Title = "Miscellaneous", Icon = "package" }),
    CreditsTab = Tabs.Credits:Tab({ Title = "Credits", Icon = "star" }),
    AppearanceTab = Tabs.Settings:Tab({ Title = "Appearance", Icon = "brush" }),
}

--// MAIN TAB
local TeamSection = TabHandles.MainTab:Section({ Title = "Team", Icon = "users" })
TeamSection:Button({
    Title = "Join Criminal",
    Icon = "user-x",
    Callback = function()
        -- Begin Join Criminal script
        local crimpad = workspace.Warrior.Body.Seats:GetChildren()[3]
        local oldpos = crimpad.Position
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer

        local function getTargetHRP()
            if LocalPlayer.Character then
                return LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            end
            return nil
        end

        crimpad.Size = Vector3.new(10, 1, 5)
        crimpad.Transparency = 0
        crimpad.BrickColor = BrickColor.new("Bright red")
        crimpad.Material = Enum.Material.Neon

        local hrp = getTargetHRP()
        if hrp then
            crimpad.Position = hrp.Position - Vector3.new(0, hrp.Size.Y/2 + crimpad.Size.Y/2, 0)
        end

        task.delay(5, function()
            crimpad.Position = oldpos
            crimpad.Size = Vector3.new(1,1,1)
            crimpad.Transparency = 1
            crimpad.BrickColor = BrickColor.new("Bright red")
            crimpad.Material = Enum.Material.SmoothPlastic
        end)
        -- End Join Criminal script
    end
})

--// MAIN TAB BODY SECTION
local BodySection = TabHandles.MainTab:Section({ Title = "Body", Icon = "activity" })
BodySection:Button({
    Title = "No Jump Cooldown",
    Icon = "zap",
    Callback = function()
        local Event = game:GetService("ReplicatedStorage").Events.UpdateStat
        firesignal(Event.OnClientEvent, "Stamina", 99999)
    end
})

BodySection:Button({
    Title = "Skip Treadmill",
    Icon = "fast-forward",
    Callback = function()
        local Event = game:GetService("ReplicatedStorage").Events.UpdateStat
        for i = 1, 4 do
            firesignal(Event.OnClientEvent, "Runspeed", 1)
        end
    end
})

--// VISUALS TAB
local killfeedEnabled = false

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Event = ReplicatedStorage:WaitForChild("Events"):WaitForChild("Killfeed")

local player = Players.LocalPlayer
local gui, feedFrame, layout

local function InitKillfeed()
    if gui then return end -- prevent creating multiple UIs
    gui = Instance.new("ScreenGui")
    gui.Name = "KillfeedUI"
    gui.ResetOnSpawn = false
    gui.Parent = player:WaitForChild("PlayerGui")

    feedFrame = Instance.new("Frame")
    feedFrame.Size = UDim2.new(0, 300, 1, 0)
    feedFrame.Position = UDim2.new(1, -310, 0, 0)
    feedFrame.BackgroundTransparency = 1
    feedFrame.Parent = gui

    layout = Instance.new("UIListLayout")
    layout.Parent = feedFrame
    layout.SortOrder = Enum.SortOrder.LayoutOrder
    layout.VerticalAlignment = Enum.VerticalAlignment.Top
    layout.Padding = UDim.new(0, 6)
end

local function AddKill(killerName, killerColor, weapon, victimName, victimColor, headshot, showHealth)
    if not killfeedEnabled then return end -- skip if disabled
    local entry = Instance.new("TextLabel")
    entry.Size = UDim2.new(1, 0, 0, 20)
    entry.BackgroundTransparency = 1
    entry.TextScaled = false
    entry.RichText = true
    entry.Font = Enum.Font.SourceSansBold
    entry.TextXAlignment = Enum.TextXAlignment.Left
    entry.TextStrokeTransparency = 0.8
    entry.TextSize = 18

    local text = string.format(
        "<font color='#%02x%02x%02x'>%s</font> <font color='#ff00ff'>[%s]</font> <font color='#%02x%02x%02x'>%s</font>",
        math.floor(killerColor.R * 255),
        math.floor(killerColor.G * 255),
        math.floor(killerColor.B * 255),
        killerName,
        weapon,
        math.floor(victimColor.R * 255),
        math.floor(victimColor.G * 255),
        math.floor(victimColor.B * 255),
        victimName
    )

    if headshot then text = text .. " üíÄ" end
    if showHealth then text = text .. " ‚ù§Ô∏è" end

    entry.Text = text
    entry.Parent = feedFrame

    task.delay(5, function()
        if entry then
            for i = 1, 20 do
                entry.TextTransparency = i / 20
                task.wait(0.05)
            end
            entry:Destroy()
        end
    end)
end

-- Connect the event
Event.OnClientEvent:Connect(AddKill)

-- Hook up to toggle
TabHandles.VisualsTab:Toggle({
    Title = "Custom Killfeed",
    Icon = "list",
    Value = false,
    Callback = function(state)
        killfeedEnabled = state
        if state then
            InitKillfeed()
        elseif gui then
            gui:Destroy()
            gui = nil
            feedFrame = nil
            layout = nil
        end
    end
})

--// RAGE TAB
local RageTab = TabHandles.RageTab

--// HOSTILE TELEPORTER
local HostileTeleporter = {}
local hostileRunning = false
local hostileTrackedCharacters = {}

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local playersFolder = workspace:WaitForChild("Players")
local DISTANCE_AHEAD = -5
local UPDATE_INTERVAL = 1

-- Helper functions
local function getHostileTargetHRP()
    if LocalPlayer.Character then
        return LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    end
    return nil
end

local function isHostileTarget(character)
    local player = Players:GetPlayerFromCharacter(character)
    if not player or player == LocalPlayer then return false end
    if player.Team and player.Team.Name == "Criminals" then return true end
    local status = player:FindFirstChild("Status")
    if status and status:FindFirstChild("Hostile") then
        return status.Hostile.Value == true
    end
    return false
end

local function teleportHostileInFront(character, targetHRP)
    local hrp = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if hrp and targetHRP and humanoid and not humanoid.Sit then
        local forwardPos = targetHRP.Position + targetHRP.CFrame.LookVector * DISTANCE_AHEAD
        hrp.CFrame = CFrame.new(forwardPos)
        hrp.Anchored = true
    end
end

local function trackHostile(character)
    for _, c in ipairs(hostileTrackedCharacters) do
        if c == character then return end
    end
    if isHostileTarget(character) then
        table.insert(hostileTrackedCharacters, character)
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then hrp.Anchored = true end
    end
end

local function untrackHostile(character)
    for i, c in ipairs(hostileTrackedCharacters) do
        if c == character then
            local hrp = c:FindFirstChild("HumanoidRootPart")
            if hrp then hrp.Anchored = false end
            table.remove(hostileTrackedCharacters, i)
            break
        end
    end
end

local function monitorHostilePlayer(player)
    player:GetPropertyChangedSignal("Team"):Connect(function()
        local character = player.Character
        if character then
            if isHostileTarget(character) then
                trackHostile(character)
            else
                untrackHostile(character)
            end
        end
    end)
    local status = player:FindFirstChild("Status")
    if status and status:FindFirstChild("Hostile") then
        status.Hostile.Changed:Connect(function()
            local character = player.Character
            if character then
                if isHostileTarget(character) then
                    trackHostile(character)
                else
                    untrackHostile(character)
                end
            end
        end)
    end
end

function HostileTeleporter.Start()
    if hostileRunning then return end
    hostileRunning = true
    hostileTrackedCharacters = {}

    for _, character in ipairs(playersFolder:GetChildren()) do trackHostile(character) end
    playersFolder.ChildAdded:Connect(trackHostile)

    for _, player in ipairs(Players:GetPlayers()) do monitorHostilePlayer(player) end
    Players.PlayerAdded:Connect(monitorHostilePlayer)

    spawn(function()
        while hostileRunning do
            local targetHRP = getHostileTargetHRP()
            if targetHRP then
                for _, character in ipairs(hostileTrackedCharacters) do
                    teleportHostileInFront(character, targetHRP)
                end
            end
            task.wait(UPDATE_INTERVAL)
        end
    end)
end

function HostileTeleporter.Stop()
    hostileRunning = false
    for _, character in ipairs(hostileTrackedCharacters) do
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then hrp.Anchored = false end
    end
    hostileTrackedCharacters = {}
end

--// Toggle for Hostile Teleporter
RageTab:Toggle({
    Title = "Hostile Teleporter",
    Value = false,
    Callback = function(state)
        if state then
            HostileTeleporter.Start()
        else
            HostileTeleporter.Stop()
        end
    end
})

--// POLICE/WARDEN TELEPORTER
local PoliceWardenTeleporter = {}
local policeTrackedCharacters = {}
local RunService = game:GetService("RunService")
local policeLoop

local function getPoliceTargetHRP()
    if LocalPlayer.Character then
        return LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    end
    return nil
end

local function isPoliceTarget(character)
    local player = Players:GetPlayerFromCharacter(character)
    if not player or player == LocalPlayer then return false end
    if player.Team and (player.Team.Name == "Guards" or player.Team.Name == "Warden") then return true end
    return false
end

local function teleportPoliceInFront(character, targetHRP)
    local hrp = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if hrp and targetHRP and humanoid and not humanoid.Sit then
        local forwardPos = targetHRP.Position + targetHRP.CFrame.LookVector * DISTANCE_AHEAD
        hrp.CFrame = CFrame.new(forwardPos)
        hrp.Anchored = true
    end
end

local function trackPolice(character)
    for _, c in ipairs(policeTrackedCharacters) do
        if c == character then return end
    end
    if isPoliceTarget(character) then
        table.insert(policeTrackedCharacters, character)
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then hrp.Anchored = true end
    end
end

local function untrackPolice(character)
    for i, c in ipairs(policeTrackedCharacters) do
        if c == character then
            local hrp = c:FindFirstChild("HumanoidRootPart")
            if hrp then hrp.Anchored = false end
            table.remove(policeTrackedCharacters, i)
            break
        end
    end
end

local function monitorPolicePlayer(player)
    player:GetPropertyChangedSignal("Team"):Connect(function()
        local character = player.Character
        if character then
            if isPoliceTarget(character) then
                trackPolice(character)
            else
                untrackPolice(character)
            end
        end
    end)
end

function PoliceWardenTeleporter.Start()
    for _, character in ipairs(playersFolder:GetChildren()) do trackPolice(character) end
    playersFolder.ChildAdded:Connect(trackPolice)

    for _, player in ipairs(Players:GetPlayers()) do monitorPolicePlayer(player) end
    Players.PlayerAdded:Connect(monitorPolicePlayer)

    policeLoop = RunService.Heartbeat:Connect(function()
        local targetHRP = getPoliceTargetHRP()
        if targetHRP then
            for _, character in ipairs(policeTrackedCharacters) do
                teleportPoliceInFront(character, targetHRP)
            end
        end
    end)
end

function PoliceWardenTeleporter.Stop()
    if policeLoop then
        policeLoop:Disconnect()
        policeLoop = nil
    end
    for _, character in ipairs(policeTrackedCharacters) do
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then hrp.Anchored = false end
    end
    policeTrackedCharacters = {}
end

--// Toggle for Police Teleporter
RageTab:Toggle({
    Title = "Police Teleporter",
    Value = false,
    Callback = function(state)
        if state then
            PoliceWardenTeleporter.Start()
        else
            PoliceWardenTeleporter.Stop()
        end
    end
})

TabHandles.RageTab:Toggle({ Title = "Spinbot", Value = false, Callback = function(state) end })

--// MISC TAB
TabHandles.MiscTab:Toggle({ Title = "Staff Notifier", Value = false, Callback = function(state) end })
TabHandles.MiscTab:Button({ Title = "Add Keys", Icon = "key", Callback = function() end })
TabHandles.MiscTab:Button({ Title = "Add Skins", Icon = "image", Callback = function() end })
TabHandles.MiscTab:Toggle({ Title = "Rapid Auto Farm", Value = false, Callback = function(state) end })
TabHandles.MiscTab:Toggle({ Title = "Slow Auto Farm", Value = false, Callback = function(state) end })

--// CREDITS TAB
TabHandles.CreditsTab:Paragraph({ Title = "Developers", Desc = "Your Name / Contributors", Image = "user-circle", ImageSize = 40, Color = "White" })
TabHandles.CreditsTab:Paragraph({ Title = "Special Thanks", Desc = "Primal UI & Supporters", Image = "gift", ImageSize = 40, Color = "Grey" })

--// APPEARANCE TAB
local AppearanceSection = TabHandles.AppearanceTab:Section({ Title = "Appearance Settings", Icon = "settings" })

AppearanceSection:Paragraph({
    Title = "Customize Interface",
    Desc = "Personalize your experience",
    Image = "palette",
    ImageSize = 20,
    Color = "White"
})

local themes = {}
for themeName, _ in pairs(Primal:GetThemes()) do
    table.insert(themes, themeName)
end
table.sort(themes)

local canchangetheme = true
local canchangedropdown = true

local themeDropdown = AppearanceSection:Dropdown({
    Title = "loc:THEME_SELECT",
    Values = themes,
    Value = "Dark",
    Callback = function(theme)
        canchangedropdown = false
        Primal:SetTheme(theme)
        Primal:Notify({ Title = "Theme Applied", Content = theme, Icon = "palette", Duration = 2 })
        canchangedropdown = true
    end
})

local transparencySlider = AppearanceSection:Slider({
    Title = "loc:TRANSPARENCY",
    Value = { Min = 0, Max = 1, Default = 0.2 },
    Step = 0.1,
    Callback = function(value)
        Primal.TransparencyValue = tonumber(value)
        Window:ToggleTransparency(tonumber(value) > 0)
    end
})

local ThemeToggle = AppearanceSection:Toggle({
    Title = "Enable Dark Mode",
    Desc = "Use dark color scheme",
    Value = true,
    Callback = function(state)
        if canchangetheme then Primal:SetTheme(state and "Dark" or "Light") end
        if canchangedropdown then themeDropdown:Select(state and "Dark" or "Light") end
    end
})

Primal:OnThemeChange(function(theme)
    canchangetheme = false
    ThemeToggle:Set(theme == "Dark")
    canchangetheme = true
end)

AppearanceSection:Button({
    Title = "Create New Theme",
    Icon = "plus",
    Callback = function()
        Window:Dialog({
            Title = "Create Theme",
            Content = "This feature is coming soon!",
            Buttons = { { Title = "OK", Variant = "Primary" } }
        })
    end
})